//! Grand product relations protocol for multilinear extension

use ark_ec::pairing::Pairing;
use ark_linear_sumcheck::{
    ml_sumcheck::{
        data_structures::ListOfProductsOfPolynomials,
        protocol::{prover::ProverMsg, verifier::SubClaim, IPForMLSumcheck, PolynomialInfo},
    },
    rng::{Blake2s512Rng, FeedableRNG},
    Error,
};
use ark_poly::{DenseMultilinearExtension, MultilinearExtension};
use ark_std::{marker::PhantomData, rc::Rc, vec::Vec, One, Zero};
use itertools::Itertools;

pub struct MLProdcheck<E: Pairing>(#[doc(hidden)] PhantomData<E>);

/// Proof generated by prover
pub struct Proof<E: Pairing> {
    pub sumcheck_proof: Vec<ProverMsg<E::ScalarField>>,
    pub comm_v: E::G1,
    pub comm_f: E::G1,
    pub claimed_value: E::ScalarField,
}

impl<E: Pairing> MLProdcheck<E> {
    /// Generate proof of the prod of polynomial v over {0,1}^`num_vars`
    pub fn prove(v: &DenseMultilinearExtension<E::ScalarField>) -> Result<Proof<E>, Error> {
        let m = v.num_vars();
        let mut fs_rng = Blake2s512Rng::setup();
        // fs_rng.feed(&polynomial.info())?;

        // 1. Commit to v
        let comm_v = E::G1::default();

        // 2. Compute MLE f of v:
        let mut evals = vec![E::ScalarField::zero(); 1 << (m + 1)];

        // define the claim p
        let mut p: E::ScalarField = E::ScalarField::zero();
        for l in 0..=m {
            // for each l, we need to define the MLE f over {1^l, 0, {0,1}^{m-l}}
            // for simplifying the code, define lhs = {1^l, 0}, rhs = {0,1}^{m-l}

            let ones = vec![1u8; l];

            // let mut rhs: Vec<E::ScalarField> = Vec::with_capacity(m - l);
            let x_hypercube = (0..m - l).map(|_| 0..2u8).multi_cartesian_product();
            if m == l {
                // case where m = l, hypercube is empty.
                // index = 11...0
                // TODO probably can be optimised?
                let point = [vec![E::ScalarField::one(); m], vec![E::ScalarField::zero()]].concat();
                let index = (1 << m) - 2;

                // P = v(1, 1, ..., 0)
                p = v.evaluate(&point).unwrap();
                evals[index] = p;
            } else {
                for b_x in x_hypercube {
                    let mut x: Vec<u8> = Vec::with_capacity(m - l);
                    for (_, bool_elem) in b_x.iter().enumerate() {
                        x.push(*bool_elem);
                    }
                    let f_index: Vec<u8> = [ones.clone(), vec![0u8], x.clone()].concat();
                    let f_index = f_index.iter().fold(0, |acc, b| (acc << 1) + *b as usize);

                    let y_hypercube = (0..l).map(|_| 0..2u8).multi_cartesian_product();
                    let mut xys: Vec<Vec<u8>> = Vec::with_capacity(1 << l);
                    if l == 0 {
                        xys.push(x.clone());
                    } else {
                        for b_y in y_hypercube {
                            let mut y: Vec<u8> = Vec::with_capacity(l);
                            for (_, bool_elem) in b_y.iter().enumerate() {
                                y.push(*bool_elem);
                            }
                            let xy = [x.clone(), y].concat();
                            xys.push(xy);
                        }
                    }

                    evals[f_index] = xys
                        .iter()
                        .map(|xy| {
                            // turn the u8 vector into a vector of scalar field elements
                            let point: Vec<E::ScalarField> =
                                xy.iter().map(|b| E::ScalarField::from(*b)).collect();
                            v.evaluate(&point).unwrap()
                        })
                        .product();
                }
            }
        }

        let f = DenseMultilinearExtension::from_evaluations_vec(m + 1, evals);

        // 3. Commit to f
        let comm_f = E::G1::default();

        // 4. Compute MLE g of f:
        let g = f;

        // 6. use the FS randomness to sample a random gamma

        // 7. Provide openings and proofs of f(0, gamma) = g(gamma)

        // 8. Provide openings and proofs of f(1, ..., 1, 0) = P

        // 5. Run sum check protocol on g
        let mut polynomial = ListOfProductsOfPolynomials::new(g.num_vars());
        polynomial.add_product(
            vec![Rc::new(DenseMultilinearExtension::from_evaluations_vec(
                v.num_vars() + 1,
                vec![E::ScalarField::zero()],
            ))],
            E::ScalarField::one(),
        );
        let mut prover_state = IPForMLSumcheck::prover_init(&polynomial);
        let mut verifier_msg = None;
        let mut prover_msgs = Vec::with_capacity(polynomial.num_variables);
        for _ in 0..polynomial.num_variables {
            let prover_msg = IPForMLSumcheck::prove_round(&mut prover_state, &verifier_msg);
            fs_rng.feed(&prover_msg)?;
            prover_msgs.push(prover_msg);
            verifier_msg = Some(IPForMLSumcheck::sample_round(&mut fs_rng));
        }

        Ok(Proof {
            sumcheck_proof: prover_msgs,
            comm_v,
            comm_f,
            claimed_value: p,
        })
    }

    /// Verify the claimed prod using the proof
    pub fn verify(
        polynomial_info: &PolynomialInfo,
        proof: &Proof<E>,
    ) -> Result<SubClaim<E::ScalarField>, Error> {
        let mut fs_rng = Blake2s512Rng::setup();
        fs_rng.feed(polynomial_info)?;
        let mut verifier_state = IPForMLSumcheck::verifier_init(polynomial_info);
        for i in 0..polynomial_info.num_variables {
            let prover_msg = proof.sumcheck_proof.get(i).expect("proof is incomplete");
            fs_rng.feed(prover_msg)?;
            let _verifier_msg = IPForMLSumcheck::verify_round(
                (*prover_msg).clone(),
                &mut verifier_state,
                &mut fs_rng,
            );
        }

        IPForMLSumcheck::check_and_generate_subclaim(verifier_state, proof.claimed_value)
    }
}
