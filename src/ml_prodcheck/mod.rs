//! Grand product relations protocol for multilinear extension

use ark_ec::pairing::Pairing;
use ark_linear_sumcheck::{
    ml_sumcheck::{
        data_structures::ListOfProductsOfPolynomials,
        protocol::{prover::ProverMsg, verifier::SubClaim, IPForMLSumcheck, PolynomialInfo},
    },
    rng::{Blake2s512Rng, FeedableRNG},
    Error,
};
use ark_poly::{DenseMultilinearExtension, MultilinearExtension};
use ark_std::{marker::PhantomData, rc::Rc, vec::Vec, One, Zero};

pub struct MLProdcheck<E: Pairing>(#[doc(hidden)] PhantomData<E>);

/// Proof generated by prover
pub struct Proof<E: Pairing> {
    pub sumcheck_proof: Vec<ProverMsg<E::ScalarField>>,
    pub comm_v: E::G1,
    pub comm_f: E::G1,
    pub claimed_value: E::ScalarField,
}

impl<E: Pairing> MLProdcheck<E> {
    /// Generate proof of the prod of polynomial v over {0,1}^`num_vars`
    pub fn prove(v: &DenseMultilinearExtension<E::ScalarField>) -> Result<Proof<E>, Error> {
        let mut fs_rng = Blake2s512Rng::setup();
        // fs_rng.feed(&polynomial.info())?;

        // 1. Commit to v
        let comm_v = E::G1::default();

        // 3. Commit to f
        let comm_f = E::G1::default();

        // 4. Compute MLE g of f:
        let (g, p) = compute_f::<E>(v);

        // 6. use the FS randomness to sample a random gamma

        // 7. Provide openings and proofs of f(0, gamma) = g(gamma)

        // 8. Provide openings and proofs of f(1, ..., 1, 0) = P

        // 5. Run sum check protocol on g
        let mut polynomial = ListOfProductsOfPolynomials::new(g.num_vars());
        polynomial.add_product(
            vec![Rc::new(DenseMultilinearExtension::from_evaluations_vec(
                v.num_vars() + 1,
                vec![E::ScalarField::zero()],
            ))],
            E::ScalarField::one(),
        );
        let mut prover_state = IPForMLSumcheck::prover_init(&polynomial);
        let mut verifier_msg = None;
        let mut prover_msgs = Vec::with_capacity(polynomial.num_variables);
        for _ in 0..polynomial.num_variables {
            let prover_msg = IPForMLSumcheck::prove_round(&mut prover_state, &verifier_msg);
            fs_rng.feed(&prover_msg)?;
            prover_msgs.push(prover_msg);
            verifier_msg = Some(IPForMLSumcheck::sample_round(&mut fs_rng));
        }

        Ok(Proof {
            sumcheck_proof: prover_msgs,
            comm_v,
            comm_f,
            claimed_value: p,
        })
    }

    /// Verify the claimed prod using the proof
    pub fn verify(
        polynomial_info: &PolynomialInfo,
        proof: &Proof<E>,
    ) -> Result<SubClaim<E::ScalarField>, Error> {
        let mut fs_rng = Blake2s512Rng::setup();
        fs_rng.feed(polynomial_info)?;
        let mut verifier_state = IPForMLSumcheck::verifier_init(polynomial_info);
        for i in 0..polynomial_info.num_variables {
            let prover_msg = proof.sumcheck_proof.get(i).expect("proof is incomplete");
            fs_rng.feed(prover_msg)?;
            let _verifier_msg = IPForMLSumcheck::verify_round(
                (*prover_msg).clone(),
                &mut verifier_state,
                &mut fs_rng,
            );
        }

        IPForMLSumcheck::check_and_generate_subclaim(verifier_state, proof.claimed_value)
    }
}

// Compute MLE f of v in v.num_vars() + 1 variables
pub fn compute_f<E: Pairing>(
    v: &DenseMultilinearExtension<E::ScalarField>,
) -> (DenseMultilinearExtension<E::ScalarField>, E::ScalarField) {
    let s = v.num_vars();
    let mut evals = vec![E::ScalarField::zero(); 1 << (s + 1)];

    // cover the case when x_hypercube is empty
    if s == 0 {
        evals[0] = v.evaluations[0];
    }

    // case where first element is 0:
    for b_x in 0..(1 << s) {
        let v_index = usize::from_le(b_x);
        let f_index = v_index << 1;
        evals[f_index] = v.evaluations[v_index];
    }

    // case where first element is 1:
    for b_x in 0..(1 << s) {
        let v_index = usize::from_le(b_x);
        let f_index = (v_index << 1) + 1;

        let f_index_l = v_index;
        let f_index_r = v_index + (1 << s);

        evals[f_index] = evals[f_index_l] * &evals[f_index_r];
    }

    // Extract the claim P. It's at index f(1,1,1,...0), i.e. in LE b0111..., or (1<<s) - 1
    let index = (1 << s) - 1;
    let p = evals[index];

    let f = DenseMultilinearExtension::from_evaluations_vec(s + 1, evals);
    (f, p)
}

#[cfg(test)]
mod tests {
    use ark_poly::{DenseMultilinearExtension, MultilinearExtension};
    use ark_std::test_rng;
    use ark_test_curves::bls12_381::{Bls12_381, Fr};

    use crate::ml_prodcheck::compute_f;
    use ark_std::{One, UniformRand, Zero};

    #[test]
    fn f_computed_correctly() {
        let mut rng = test_rng();
        for s in 0..=10 {
            let v = DenseMultilinearExtension::<Fr>::rand(s, &mut rng);
            let (f, p) = compute_f::<Bls12_381>(&v);

            // assert f(1, 1, ..., 0) = P
            let mut f_point = vec![Fr::one(); s];
            f_point.push(Fr::zero());
            assert_eq!(p, f.evaluate(&f_point).unwrap());

            let mut f_point = vec![Fr::zero()];
            let v_point: Vec<_> = (0..s).map(|_| Fr::rand(&mut rng)).collect();
            f_point.extend(&v_point);
            // assert v(r) = f(0, r)
            assert_eq!(v.evaluate(&v_point).unwrap(), f.evaluate(&f_point).unwrap());
        }
    }
}
