//! Grand product relations protocol for multilinear extension

use ark_ec::pairing::Pairing;
use ark_linear_sumcheck::{
    ml_sumcheck::{
        data_structures::ListOfProductsOfPolynomials,
        protocol::{prover::ProverMsg, verifier::SubClaim, IPForMLSumcheck, PolynomialInfo},
    },
    rng::{Blake2s512Rng, FeedableRNG},
    Error,
};
use ark_poly::{DenseMultilinearExtension, MultilinearExtension};
use ark_std::{marker::PhantomData, rc::Rc, vec::Vec, One, Zero};
use itertools::Itertools;

pub struct MLProdcheck<E: Pairing>(#[doc(hidden)] PhantomData<E>);

/// Proof generated by prover
pub struct Proof<E: Pairing> {
    pub sumcheck_proof: Vec<ProverMsg<E::ScalarField>>,
    pub comm_v: E::G1,
    pub comm_f: E::G1,
    pub claimed_value: E::ScalarField,
}

impl<E: Pairing> MLProdcheck<E> {
    /// Generate proof of the prod of polynomial v over {0,1}^`num_vars`
    pub fn prove(v: &DenseMultilinearExtension<E::ScalarField>) -> Result<Proof<E>, Error> {
        let mut fs_rng = Blake2s512Rng::setup();
        // fs_rng.feed(&polynomial.info())?;

        // 1. Commit to v
        let comm_v = E::G1::default();

        // 3. Commit to f
        let comm_f = E::G1::default();

        // 4. Compute MLE g of f:
        let (g, p) = compute_f::<E>(v);

        // 6. use the FS randomness to sample a random gamma

        // 7. Provide openings and proofs of f(0, gamma) = g(gamma)

        // 8. Provide openings and proofs of f(1, ..., 1, 0) = P

        // 5. Run sum check protocol on g
        let mut polynomial = ListOfProductsOfPolynomials::new(g.num_vars());
        polynomial.add_product(
            vec![Rc::new(DenseMultilinearExtension::from_evaluations_vec(
                v.num_vars() + 1,
                vec![E::ScalarField::zero()],
            ))],
            E::ScalarField::one(),
        );
        let mut prover_state = IPForMLSumcheck::prover_init(&polynomial);
        let mut verifier_msg = None;
        let mut prover_msgs = Vec::with_capacity(polynomial.num_variables);
        for _ in 0..polynomial.num_variables {
            let prover_msg = IPForMLSumcheck::prove_round(&mut prover_state, &verifier_msg);
            fs_rng.feed(&prover_msg)?;
            prover_msgs.push(prover_msg);
            verifier_msg = Some(IPForMLSumcheck::sample_round(&mut fs_rng));
        }

        Ok(Proof {
            sumcheck_proof: prover_msgs,
            comm_v,
            comm_f,
            claimed_value: p,
        })
    }

    /// Verify the claimed prod using the proof
    pub fn verify(
        polynomial_info: &PolynomialInfo,
        proof: &Proof<E>,
    ) -> Result<SubClaim<E::ScalarField>, Error> {
        let mut fs_rng = Blake2s512Rng::setup();
        fs_rng.feed(polynomial_info)?;
        let mut verifier_state = IPForMLSumcheck::verifier_init(polynomial_info);
        for i in 0..polynomial_info.num_variables {
            let prover_msg = proof.sumcheck_proof.get(i).expect("proof is incomplete");
            fs_rng.feed(prover_msg)?;
            let _verifier_msg = IPForMLSumcheck::verify_round(
                (*prover_msg).clone(),
                &mut verifier_state,
                &mut fs_rng,
            );
        }

        IPForMLSumcheck::check_and_generate_subclaim(verifier_state, proof.claimed_value)
    }
}

fn compute_f<E: Pairing>(
    v: &DenseMultilinearExtension<E::ScalarField>,
) -> (DenseMultilinearExtension<E::ScalarField>, E::ScalarField) {
    let m = v.num_vars();
    // 2. Compute MLE f of v:
    let mut evals = vec![E::ScalarField::zero(); 1 << (m + 1)];

    // define the claim p
    let mut p: E::ScalarField = E::ScalarField::zero();
    for l in 0..=m {
        // for each l, we need to define the MLE f over {1^l, 0, {0,1}^{m-l}}
        // for simplifying the code, define lhs = {1^l, 0}, rhs = {0,1}^{m-l}

        let ones = vec![1u8; l];

        // let mut rhs: Vec<E::ScalarField> = Vec::with_capacity(m - l);
        let x_hypercube = (0..m - l).map(|_| 0..2u8).multi_cartesian_product();
        if m == l {
            // P = f(1, 1, ..., 0)

            // case where m = l, x_hypercube is empty.
            // index = 11...0
            let index = (1 << m) - 1;
            let x = vec![];
            p = compute_xy_vectors_from_x::<E>(x, l, &v);

            evals[index] = p;
        } else {
            for b_x in x_hypercube {
                let mut x: Vec<u8> = Vec::with_capacity(m - l);
                for (_, bool_elem) in b_x.iter().enumerate() {
                    x.push(*bool_elem);
                }
                let f_index: Vec<u8> = [ones.clone(), vec![0u8], x.clone()].concat();
                let f_index = f_index
                    .iter()
                    .rev()
                    .fold(0, |acc, b| (acc << 1) + *b as usize);

                let prod = compute_xy_vectors_from_x::<E>(x, l, &v);

                evals[f_index] = prod;
            }
        }
    }

    let f = DenseMultilinearExtension::from_evaluations_vec(m + 1, evals);
    (f, p)
}

#[inline(always)]
fn compute_xy_vectors_from_x<E: Pairing>(
    x: Vec<u8>,
    l: usize,
    v: &DenseMultilinearExtension<E::ScalarField>,
) -> E::ScalarField {
    let y_hypercube = (0..l).map(|_| 0..2u8).multi_cartesian_product();
    let mut xys: Vec<Vec<u8>> = Vec::with_capacity(1 << l);
    if l == 0 {
        xys.push(x.clone());
    } else {
        for b_y in y_hypercube {
            let mut y: Vec<u8> = Vec::with_capacity(l);
            for (_, bool_elem) in b_y.iter().enumerate() {
                y.push(*bool_elem);
            }
            let xy = [x.clone(), y].concat();
            xys.push(xy);
        }
    }
    xys.iter()
        .map(|xy| {
            // turn the u8 vector into a vector of scalar field elements
            let point: Vec<E::ScalarField> =
                xy.iter().map(|b| E::ScalarField::from(*b)).collect();
            v.evaluate(&point).unwrap()
        })
        .product()
}

#[cfg(test)]
mod tests {
    use ark_poly::{DenseMultilinearExtension, MultilinearExtension};
    use ark_std::test_rng;
    use ark_test_curves::bls12_381::{Bls12_381, Fr};

    use crate::ml_prodcheck::compute_f;
    use ark_std::{One, UniformRand, Zero};

    use super::compute_xy_vectors_from_x;

    #[test]
    fn xy_computed_correctly() {
        let mut rng = test_rng();
        for _ in 0..100 {
            let v = DenseMultilinearExtension::<Fr>::rand(3, &mut rng);

            let x = vec![1u8, 0u8, 1u8];
            let l = 0;
            let p = compute_xy_vectors_from_x::<Bls12_381>(x, l, &v);
            let expected = v
                .evaluate(&[Fr::from(1), Fr::from(0), Fr::from(1)])
                .unwrap();
            assert_eq!(p, expected);

            let x = vec![1u8, 0u8];
            let l = 1;
            let p = compute_xy_vectors_from_x::<Bls12_381>(x, l, &v);
            let expected = v
                .evaluate(&[Fr::from(1), Fr::from(0), Fr::from(0)])
                .unwrap()
                * v.evaluate(&[Fr::from(1), Fr::from(0), Fr::from(1)])
                    .unwrap();
            assert_eq!(p, expected);

            let x = vec![1u8];
            let l = 2;
            let p = compute_xy_vectors_from_x::<Bls12_381>(x, l, &v);
            let expected = v
                .evaluate(&[Fr::from(1), Fr::from(0), Fr::from(0)])
                .unwrap()
                * v.evaluate(&[Fr::from(1), Fr::from(0), Fr::from(1)])
                    .unwrap()
                * v.evaluate(&[Fr::from(1), Fr::from(1), Fr::from(0)])
                    .unwrap()
                * v.evaluate(&[Fr::from(1), Fr::from(1), Fr::from(1)])
                    .unwrap();
            assert_eq!(p, expected);

            let x = vec![];
            let l = 3;
            let p = compute_xy_vectors_from_x::<Bls12_381>(x, l, &v);
            let expected = v
                .evaluate(&[Fr::from(0), Fr::from(0), Fr::from(0)])
                .unwrap()
                * v.evaluate(&[Fr::from(0), Fr::from(0), Fr::from(1)])
                    .unwrap()
                * v.evaluate(&[Fr::from(0), Fr::from(1), Fr::from(0)])
                    .unwrap()
                * v.evaluate(&[Fr::from(0), Fr::from(1), Fr::from(1)])
                    .unwrap()
                * v.evaluate(&[Fr::from(1), Fr::from(0), Fr::from(0)])
                    .unwrap()
                * v.evaluate(&[Fr::from(1), Fr::from(0), Fr::from(1)])
                    .unwrap()
                * v.evaluate(&[Fr::from(1), Fr::from(1), Fr::from(0)])
                    .unwrap()
                * v.evaluate(&[Fr::from(1), Fr::from(1), Fr::from(1)])
                    .unwrap();
            assert_eq!(p, expected);
        }
    }

    #[test]
    fn f_computed_correctly() {
        let mut rng = test_rng();
        let m = 0;
        let v = DenseMultilinearExtension::<Fr>::rand(m, &mut rng);
        let (f, p) = compute_f::<Bls12_381>(&v);

        // assert f(1, 1, ..., 0) = P
        let mut f_point = vec![Fr::one(); m];
        f_point.push(Fr::zero());
        assert_eq!(p, f.evaluate(&f_point).unwrap());

        let mut f_point = vec![Fr::zero()];
        let bool_point: Vec<_> = (0..m).map(|_| bool::rand(&mut rng)).collect();
        let v_point: Vec<_> = bool_point.iter().map(|b| Fr::from(*b as u8)).collect();
        f_point.extend(&v_point);
        // assert v(r) = f(0, r)
        assert_eq!(v.evaluate(&v_point).unwrap(), f.evaluate(&f_point).unwrap());
    }
}
